import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  user_name: {
    type: String,
    required: [true, "User Name is required"],
  },
  email: {
    type: String,
    unique: true,
    required: [true, "email is required"],
  },
  password: {
    type: String,
    required: [true, "password is required"],
  },
}, { timestamps: true });

export default mongoose.model("User", userSchema);
=>
import mongoose from "mongoose";

const chatSchema = new mongoose.Schema({
  isGroupChat: { type: Boolean, default: false },
  groupName: {
    type: String,
    required: function () { return this.isGroupChat; },
    unique: function () { return this.isGroupChat; },
  },
  users: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }],
  groupAdmin: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: function () { return this.isGroupChat; },
  },
  latestMessage: { type: mongoose.Schema.Types.ObjectId, ref: "Message" },
}, { timestamps: true });

export default mongoose.model("Chat", chatSchema);
=>
import mongoose from "mongoose";

const messageSchema = new mongoose.Schema({
  sender: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
  content: { type: String, required: true },
  chatId: { type: mongoose.Schema.Types.ObjectId, ref: "Chat", required: true }, // Refers to Chat model
}, { timestamps: true });

export default mongoose.model("Message", messageSchema);
=>
import { Server } from "socket.io";
import http from "http";
import express from "express";
import cors from "cors";
import connectDB from "./config/db.js";
import morgan from "morgan";
import dotenv from "dotenv";
import authRoute from "./routes/authRoute.js";
import chatRoute from "./routes/chatRoute.js";

const app = express();
const server = http.createServer(app);

dotenv.config();
connectDB();
app.use(express.json());
app.use(morgan("dev"));
app.use(cors());

app.use("/api/v1/auth", authRoute);
app.use("/api/v1/chat", chatRoute);

const io = new Server(server, {
  cors: {
    origin: "http://localhost:5173",
    methods: ["GET", "POST"],
    credentials: true,
  },
});
io.on("connection", (socket) => {
  console.log("A user connected:", socket.id);

  // Listen for 'join-room' event to join the group chat room using the groupId
  socket.on("join-room", (groupId) => {
    console.log(`User ${socket.id} joining group room ${groupId}`);
    socket.join(groupId); // Join the room (group chat)
    console.log(`User ${socket.id} joined group room ${groupId}`);
  });

  // Listen for 'private-room' event to join the private chat room using the userId
  socket.on("private-room", (userId) => {
    console.log(`User ${socket.id} joining private room for user ${userId}`);
    socket.join(userId); // Join the private chat room (user's ID)
    console.log(`User ${socket.id} joined private room for user ${userId}`);
  });

  // Handle disconnection
  socket.on("disconnect", () => {
    console.log("A user disconnected:", socket.id);
  });
});
const PORT = process.env.PORT || 8080;

server.listen(PORT, "0.0.0.0", () => {
  console.log(`Server is running on port ${PORT}`);
});

export { app, server, io };
=>
export const sendMessageController = async (req, res) => {
  try {
    const { userId } = req;
    const { content, isGroupChat, receiver, groupId } = req.body;

    if (isGroupChat === true || isGroupChat === 'true') {
      const groupChat = await chatSchema.findById(groupId).populate('users');
      if (!groupChat) {
        return res.status(404).json({ message: "Group chat not found" });
      }

      const newMessage = new messageSchema({
        sender: userId,
        content,
        chatId: groupChat._id, // Group chat ID
      });

      // Save the new message to the database
      await newMessage.save();

      // Update the latestMessage field in the chat document
      groupChat.latestMessage = newMessage._id;
      await groupChat.save();

      // Emit the message to all users in the group chat
      groupChat.users.forEach(user => {
        io.to(user._id.toString()).emit("receive_message", {
          sender: userId,
          content,
          createdAt: newMessage.createdAt,
          groupId: groupChat._id,
          isGroupChat: true,
        });
      });

      return res.status(200).json({ message: "Message sent successfully", data: newMessage });
    } else {
      let personalChat = await chatSchema.findOne({
        isGroupChat: false,
        users: { $all: [userId, receiver] },
      });

      if (!personalChat) {
        personalChat = new chatSchema({
          isGroupChat: false,
          users: [userId, receiver],
        });
        await personalChat.save();
      }

      const newMessage = new messageSchema({
        sender: userId,
        content,
        chatId: personalChat._id, // Personal chat ID
      });

      // Save the new message to the database
      await newMessage.save();
      personalChat.latestMessage = newMessage._id;
      await personalChat.save();
      
      io.to(receiver).emit("receive_message", {
        sender: userId,
        content,
        createdAt: newMessage.createdAt,
        isGroupChat: false,
        chatId: personalChat._id,
      });

      return res.status(200).json({ message: "Message sent successfully", data: newMessage });
    }
  } catch (error) {
    console.error(error);
    return res.status(500).json({ message: "Error sending message", error });
  }
};
=>
  useEffect(() => {
    //will look into the frontend later after server side is done so dont focus on frontend for now
    if (isSelectedUser) {
      socket.on('connected', (message) => {
        console.log(message); // This will log "Connected to the server: <socketId>"
      });
      // Check if the chat is a group or private chat and join the corresponding room
      if (isGroupChat) {
        socket.emit("join-room", isSelectedUser); // Group chat
      } else {
        socket.emit("private-room", isSelectedUser); // Private chat (use user's _id)
      }
      socket.on("receive_message", (newMessage) => {
        console.log('newMessage: ', newMessage);
       dispatch(MergeChats([...isChatHistory,{newMessage}]))
      });

      // Clean up socket when component is unmounted or user changes
      // return () => {
      //   socket.disconnect();
      //   console.log("Disconnected from the server");
      // };
    }
  }, [isSelectedUser, isGroupChat]); 